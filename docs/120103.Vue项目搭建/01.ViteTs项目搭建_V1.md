---
title: ViteTs项目搭建
date: 2023-05-13 11:14:33
permalink: /pages/7b2c15/
categories:
  - Vue项目搭建
tags:
  - 
author: 
  name: xiaoliuxuesheng
  link: https://gitee.com/xiaoliuxuesheng
---

## 1.1 Vue项目创建

> 使用Vite创建Vue项目：Vite官网：https://cn.vitejs.dev/guide/

- 使用Vite搭建Vue项目

  ```shell
  pnpm create vite
  ```

  > ```shell
  > ? Project name: » web-tmp-vite-ts
  > 
  > ? Select a framework: » - Use arrow-keys. Return to submit.
  >     Vanilla
  > >   Vue
  >     React
  >     Preact
  >     Lit
  >     Svelte
  >     Others
  >     
  > >   TypeScript
  >     JavaScript
  >     Customize with create-vue ↗
  >     Nuxt ↗
  > ```

- 创建完成

  ```shell
  Done. Now run:
  
    cd web-tmp-vite-ts
    pnpm install
    pnpm run dev
  ```

## 1.2 Vite项目配置

### 1. 启动端口配置

- 修改配置文件：vite.config.ts中新增`server`配置项

  ```tsx
  export default defineConfig({
      server: {
          // 是否自动打开浏览器
          open: true,
          // 服务器主机名，如果允许外部访问，可设置为"0.0.0.0"
          host: '0.0.0.0',
          // 服务器端口号
          port: 8090,
          // 设为 true ,若端口已被占用则会直接退出，而不是尝试下一个可用端口
          strictPort: false,
          // 为开发服务器配置 CORS
          cors: true,
          // 设置为 true 强制使依赖预构建
          force: true,
      }
  })
  ```

  > 启动：pnpm run dev
  >
  > Port 8090 is in use, trying another one...
  >
  >   VITE v4.3.2  ready in 307 ms
  >
  >   ➜  Local:   http://localhost:8091/    
  >   ➜  Network: http://192.168.132.1:8091/
  >   ➜  Network: http://192.168.10.1:8091/
  >   ➜  Network: http://192.168.0.106:8091/

### 2. 设置路径别名

- 安装路径解析依赖包

  ```shell
  pnpm i @types/node -D
  ```

- 配置文件中添加别名配置项：vite.config.ts中的resolve

  ```tsx
  // 路径解析器
  import {resolve} from 'path'
  
  export default defineConfig({
      resolve: {
        alias: {
          '@': resolve(__dirname, 'src')
          },
        extensions: ['.js', '.ts', '.vue', '.json', '.scss', '.css']
      }
  })
  ```

- 在tsconfig.json配置中添加路径解析配置

  ```json
  {
    "compilerOptions": {
      // 用于设置解析非相对模块名称的基本目录，相对模块不会受到baseUrl的影响
      "baseUrl": ".",
      // 用于设置模块名到基于baseUrl的路径映射
      "paths": {
        "@/*": ["src/*"]
      }
    },
  }
  ```

- 测试别名：修改App.vue中的HelloWorld的import

  ```tsx
  import HelloWorld from '@/components/HelloWorld'
  ```

### 3. 集成Axios

> axios官网：https://www.axios-http.cn/
>
> Github地址：https://github.com/axios/axios

- 安装axios相关依赖

  ```shell
  pnpm install --save axios
  ```

- axios封装`AxiosClient.ts`：①请求响应拦截器需要进行扩展、②单个请求的配置可以覆盖默认的请求信息、③自定义请求扩展参数

  ```tsx
  import axios from 'axios'
  import type {
      AxiosInstance,
      AxiosResponse,
      AxiosRequestConfig,
      InternalAxiosRequestConfig,
      AxiosRequestHeaders,
  } from 'axios'
  
  
  // 拦截器配置：由实际业务的http进行配置
  export interface InterceptorHook {
      requestInterceptor?: (config: InternalAxiosRequestConfig) => InternalAxiosRequestConfig
      requestInterceptorCatch?: (error: any) => any
      responseInterceptor?: (response: AxiosResponse) => AxiosResponse | Promise<AxiosResponse>
      responseInterceptorCatch?: (error: any) => any
  }
  
  // 拦截器请求config
  export interface InterceptorRequestConfig<D = any> extends InternalAxiosRequestConfig<D> {
      interceptorHooks?: InterceptorHook
      requestOptions?: RequestOptions
  }
  
  // 拓展axios请求参数，加入自己的配置
  interface RequestOptions {
      // 是否全局展示请求 错误信息
      globalErrorMessage?: boolean
      // 是否全局展示请求 成功信息
      globalSuccessMessage?: boolean
  }
  
  // 自定义Axios请求config
  export interface RequestConfig<D = any> extends AxiosRequestConfig<D> {
      interceptorHooks?: InterceptorHook
      requestOptions?: RequestOptions
  }
  
  // 自定义Axios响应config
  export interface ResponseConfig<T = any, D = any> extends AxiosResponse<T, D> {
      config: InterceptorRequestConfig<D>
  }
  
  export class Request {
      // axios 实例
      private _instance: AxiosInstance
      private _interceptorHooks?: InterceptorHook
      // 默认配置
      private _defaultConfig: RequestConfig = {
          baseURL: '/api',
          timeout: 5000,
          requestOptions: {
              globalErrorMessage: true,
              globalSuccessMessage: false,
          },
          headers: {} as AxiosRequestHeaders,
      }
      constructor(config: RequestConfig) {
          // 使用axios.create创建axios实例
          this._instance = axios.create(Object.assign(this._defaultConfig, config))
          this._interceptorHooks = config.interceptorHooks
          this.setupInterceptors()
      }
      // 通用拦截，在初始化时就进行注册和运行，对基础属性进行处理
      private setupInterceptors() {
          this._instance.interceptors.request.use(
              this._interceptorHooks?.requestInterceptor,
              this._interceptorHooks?.requestInterceptorCatch
          )
          this._instance.interceptors.response.use(
              this._interceptorHooks?.responseInterceptor,
              this._interceptorHooks?.responseInterceptorCatch
          )
      }
      // 定义核心请求
      public request(config: RequestConfig): Promise<AxiosResponse> {
          // ！！！?? 注意：axios 已经将请求使用 promise 封装过了
          // 这里直接返回，不需要我们再使用 promise 封装一层
          return this._instance.request(config)
      }
      public get<T = any>(url: string, config?: RequestConfig): Promise<T> {
          return this._instance.get(url, config)
      }
      public post<T = any>(url: string, data?: any, config?: RequestConfig): Promise<T> {
          return this._instance.post(url, data, config)
      }
      public put<T = any>(url: string, data?: any, config?: RequestConfig): Promise<T> {
          return this._instance.put(url, data, config)
      }
      public delete<T = any>(url: string, config?: RequestConfig): Promise<T> {
          return this._instance.delete(url, config)
      }
  }
  ```

  > 扩展请求参数，自定义请求参数类型：如下加入消息提示的配置
  >
  > 新版本Axios的请求的config类型：InternalAxiosRequestConfig，自定义请求和响应对添加拦截回调和请求参数进行封装：响应结构中会带请求配置信息，所以修改了请求的config，同时需要修改响应结果的config

- 根据封装的Axios定义业务请求的Http

  ```tsx
  import { Request, InterceptorHook, ResponseConfig } from '@/util/AxiosClient'
  import type { AxiosRequestHeaders } from 'axios'
  // 请求拦截器
  const transform: InterceptorHook = {
      // 请求
      requestInterceptor(config) {
          // 请求头部处理，如添加 token
          return config
      },
      // 异常拦截
      requestInterceptorCatch(err) {
          // 请求错误，这里可以用全局提示框进行提示
          return Promise.reject(err)
      },
      // 响应拦截
      responseInterceptor(result) {
          console.log({ result })
          // 因为 axios 返回不支持扩展自定义配置，需要自己断言一下
          const res = result as ResponseConfig
          console.log({ res })
          if (res.status !== 200) {
              return Promise.reject(res)
          }
          // 开启全局提示
          if (res.config.requestOptions?.globalSuccessMessage) {
              // 这里全局提示请求成功
              console.log('这里全局提示请求成功', res.data)
          }
          // 与后端约定的请求成功码 这里全局提示请求成功
          if (res.config.requestOptions?.globalSuccessMessage) {
              console.log(res.data.message)
          }
          // 请求返回值，建议将 返回值 进行解构
          return res.data
      },
      responseInterceptorCatch(err) {
          // 这里用来处理 http 常见错误，进行全局提示
          const mapErrorStatus = new Map([
              [400, '请求方式错误'],
              [401, '请重新登录'],
              [403, '拒绝访问'],
              [404, '请求地址有误'],
              [500, '服务器出错'],
          ])
          const message = mapErrorStatus.get(err.response.status) || '请求出错，请稍后再试'
          // 此处全局报错
          console.error(message)
          return Promise.reject(err.response)
      },
  }
  // 具体使用时先实例一个请求对象
  export const request = new Request({
      // baseURL: '/api',
      timeout: 5000,
      interceptorHooks: transform,
      headers: { Authorization: 'tokenaaaaa' } as AxiosRequestHeaders,
  })
  
  ```

- 测试API请求

  ```tsx
  export interface IPType {
      asn: string
      city: string
      continent_code: string
      country: string
      country_area: string
      country_calling_code: string
      country_capital: string
      country_code: string
      country_code_iso3: string
      country_name: string
      country_population: string
      country_tld: string
      currency: string
      currency_name: string
      in_eu: boolean
      ip: string
      languages: string
      latitude: number
      longitude: number
      network: string
      org: string
      postal: string
      region: string
      region_code: string
      timezone: string
      utc_offset: string
      version: string
  }
  ```

  ```tsx
  import type {RequestConfig} from '@/util/AxiosClient'
  import {request} from '@/util/UserHttp'
  import {IPType} from '@/types/IPType'
  
  const config:RequestConfig = {
    requestOptions: {
      globalSuccessMessage: true
    }
  }
  request.get<IPType>('https://ipapi.co/8.8.8.8/json/',config).then(res => {
    console.log(res);
    console.log(res.asn);
    console.log(res.currency_name);
    console.log(res.city);
  })
  ```

### 4. 添加环境配置文件

- 在项目根目录定义配置文件：`.evn.环境标识`

  ```tex
  .env.mock
  .env.dev
  .env.test
  .dev.prod
  ```

- 添加测定配置内容：配置文件中属性必须是`VITE_`开头

  ```properties
  VITE_MODE_NAME=mock
  VITE_BASE_URL=http://localhost:9002/mock/
  ```

- package.json新增启动script，指定启动环境

  ```tsx
  {
      "scripts": {
        "mock": "vite  --mode mock",
        "dev": "vite  --mode dev",
        "test": "vite  --mode test",
        "prod": "vite  --mode prod",
    }
  }
  ```

- 读取配置文件中配置信息

  ```tsx
  const env = import.meta.env.VITE_BASE_URL
  ```

- 运行项目测试读取配置

  ```shell
  npm run mock
  ```

### 5. 集成MockJS

- 安装Mock.js依赖及插件

  ```shell
  pnpm i --save-dev @types/mockjs
  pnpm install vite-plugin-mock cross-env -D
  ```

- 置Mock插件：在`vite.config.ts`添加Mock插件配置

  ```tsx
  import { defineConfig } from 'vite'
  import vue from '@vitejs/plugin-vue'
  // 路径解析器
  import {resolve} from 'path'
  import {viteMockServe} from "vite-plugin-mock";
  
  // https://vitejs.dev/config/
  export default defineConfig({
    plugins: [
      // 插件中添加mockServer
      viteMockServe({
        // 解析根目录下的mock文件夹
        mockPath: 'mock',
        // 开发打包开关
        localEnabled: true,
        // 生产打包开关
        prodEnabled: false,
        // 打开后，可以读取 ts 文件模块。 请注意，打开后将无法监视.js 文件。
        supportTs: true,
        // 监视文件更改
        watchFiles: true
      })
    ],
    server: {
      // 在server中添加mock代理
      proxy: {
        "/mock" : {
          target: 'http://localhost:8090',
          changeOrigin: true,
          rewrite: (path) => path.replace(/^\/mock/, '')
        }
      }
    }
  })
  
  ```

- 根目录中新建mock目录添加Mock脚本

  ```tsx
  // 测试脚本: /mock/TestMock.ts
  import {MockMethod} from "vite-plugin-mock";
  const userApis:MockMethod[] = [
      {
          url: '/mock/product',
          method: 'post',
          response: () => {
              return{
                  code: 200200,
                  msg: 'success',
                  data: {
                      name: "商品",
                      age: 2323
                  }
              }
          }
      }
  ]
  export default userApis
  
  // 测试脚本: /mock/UserMock.ts
  import {MockMethod} from "vite-plugin-mock";
  const userApis:MockMethod[] = [
      {
          url: '/mock/user',
          method: 'post',
          response: () => {
              return{
                  code: 200200,
                  msg: 'success',
                  data: {
                      name: "张三",
                      age: 23
                  }
              }
          }
      }
  ]
  export default userApis
  ```

- 编写API测试方法

  ```tsx
  import {ResponseData} from "@/types/common/ResponseData";
  import {httpClient} from "@/utils/HttpClient";
  
  export interface UserRequest {
      name: string
  }
  export interface User {
      name: string,
      age: number
  }
  
  export function getUser(name: UserRequest):Promise<ResponseData<User>>{
      return httpClient.post("/user", name);
  }
  
  export function getProduct(name: UserRequest):Promise<ResponseData<User>>{
      return httpClient.post("/product", name);
  }
  ```

- 测试请求发送

  ```tsx
  import {getProduct, getUser} from "@/api/MockApi";
  getUser({name: "战三"}).then(res => {
    console.log(res.data)
    console.log(res)
  })
  
  getProduct({name: "战三"}).then(res => {
    console.log(res)
  })
  ```

### 6. 集成router4

- 安装Router4

  ```shell
  pnpm install vue-router
  ```

- 添加Router配置文件

  1. 在src中新增`router`目录，添加index.ts配置文件，并添加404页面`/:catchAll(.*)`，**注**：该path配置不需要添加name值；

     ```tsx
     import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'
     const routes: RouteRecordRaw[] = [
         {
             path: '/:catchAll(.*)',
             component: () => import('@/views/error/index.vue')
         } as RouteRecordRaw
     ]
     const routerModules:Record<string,any> = import.meta.globEager("./modules/*.ts")
     Object.keys(routerModules).forEach(key=>{
         routes.push(...routerModules[key].default)
     })
     
     const router = createRouter({
         history: createWebHistory(),
         routes
     })
     
     export default router
     ```

  2. 再到router目录中新增modules目录，所有路由定义在该目录中，如添加测试配置：hello.ts

     ```tsx
     import {RouteRecordRaw} from "vue-router";
     const hello: RouteRecordRaw[] = [
         {
             path: '/',
             name: 'Root',
             redirect:'/hello'
         },
         {
             path: '/hello',
             name: 'Hello',
             component: () => import('@/components/HelloWorld.vue'),
             props: {
                 msg: '路由参数'
             }
         }
     ]
     export default hello
     ```

- 配置main.ts，集成Router4

  ```tsx
  import router from "@/router";
  createApp(App)
      .use(router)
      .mount('#app')
  ```

- 测试修改：App.vue中删除HelloWorld.vue组件，并添加路由配置

  ```vue
  <template>
    <router-link to="/" tag="button">HelloWorld</router-link>
    <hr>
    <router-view></router-view>
  </template>
  ```

- 配置Router动态路由

  1. 首先前端需要定义需要配的路由组件：如下，提前将需要动态匹配的组件定义在一个集合中，或者使用Vite的`import.meta.globEager("*.vue")`加载出指定目录中所有的Vue组件；

     ```tsx
     const map = {
         'Test': () => import('@/components/TestRouter.vue')
     }
     ```
  
  2. MockJS添加路由接口

     ```tsx
     ```
  
  3. 定义API接口发送请求获取路由

     ```tsx
     ```
  
  4. 动态路由配置：如下是案例代码
  
     ```tsx
     // 定义从接口返回的数据类型
     interface Menu {
         path: string,
         name: string,
         component: string;
     }
     
     // 距离从接口返回的菜单集合
     const  ms: Menu[] = [{
         path: '/test',
         name: 'Test',
         component: 'Test'
     }]
     
     // 定义一个方法将菜单集合转换为路由集合
     function buildRouter(menus: Menu[]):RouteRecordRaw[] {
         let rs: RouteRecordRaw[] = [];
         for (const menu of menus) {
             let r = {
                 path: menu.path,
                 name: menu.name,
                 component:  map[menu.component]
             } as  RouteRecordRaw;
             rs.push(r)
         }
         return rs;
     }
     
     // 在路由导航中判断是否存在路由，如果不存在则动态添加，如果添加失败会跳转404错误页面
     router.beforeEach((to, from, next) => {
         if (router.hasRoute(to.name as string)) {
             next()
         }else {
             let dynamicRouters = buildRouter(ms)
             dynamicRouters.forEach( dr => {
                 router.addRoute(ds)
             })
             next({ ...to, replace: true })
         }
     })
     export default router
     ```
  

### 7. 集成Sass

- 安装sass依赖

  ```shell
  pnpm install --save-dev sass less less-loader
  ```

- 新建测试文件：``/src/assert/scss/index.scss`和`_base.scss`

  - index.scss

    ```scss
    @import "base";
    ```

  - _base.scss

    ```scss
    $baseColor: #eeaa11;
    ```

- 配置文件vite.config.ts中添加css配置

  ```tsx
  export default defineConfig({
      css:{
          preprocessorOptions:{
              scss:{
                  javascriptEnabled: true,
                  additionalData: '@import "@/assets/scss/index.scss";'
              }
          }
      }
  })
  ```

- 测试在HelloWorld.vue中使用样式

  ```vue
  <style scoped lang="scss">
  a {
    color: $baseColor;
  }
  </style>
  ```

### 8. Icon组件封装

- 

## 1

- pnpm add eslint -D

- pnpm eslint --init

- npm init @eslint/config

  ```shell
  E:\AdminCode\business_alliances\demo01-eslint-vue-ts>pnpm eslint --init
  You can also run this command directly using 'npm init @eslint/config'.
  Need to install the following packages:
    @eslint/create-config@0.4.3
  Ok to proceed? (y) y
  √ How would you like to use ESLint? · style
  √ What type of modules does your project use? · commonjs
  √ Which framework does your project use? · vue
  √ Does your project use TypeScript? · No / Yes
  √ Where does your code run? · browser
  √ How would you like to define a style for your project? · guide
  √ Which style guide do you want to follow? · standard-with-typescript
  √ What format do you want your config file to be in? · JavaScript
  Checking peerDependencies of eslint-config-standard-with-typescript@latest
  The config that you've selected requires the following dependencies:
  
  eslint-plugin-vue@latest 
  eslint-config-standard-with-typescript@latest 
  @typescript-eslint/eslint-plugin@^5.43.0 
  eslint@^8.0.1 
  eslint-plugin-import@^2.25.2 
  eslint-plugin-n@^15.0.0 
  eslint-plugin-promise@^6.0.0 
  typescript@*
  √ Would you like to install them now? · No / Yes
  √ Which package manager do you want to use? · pnpm
  ```

- .eslintrc.cjs

  ```js
  module.exports = {
    env: {
      browser: true,
      commonjs: true,
      es2021: true
    },
    extends: [
      'plugin:vue/vue3-essential',
      'standard-with-typescript'
    ],
    overrides: [
    ],
    parserOptions: {
      ecmaVersion: 'latest'
    },
    plugins: [
      'vue'
    ],
    rules: {
    }
  }
  ```

- package.json

  ```json
  "scripts": {
      "lint": "eslint . --ext .vue,.js,.ts,.jsx,.tsx --fix"
  },
  ```

- 启动检查

  ```shell
  pnpm lint
  ```

  > - 报错
  >
  >   ```shell
  >   Error while loading rule '@typescript-eslint/dot-notation': You have used a rule which requires parserServices to be generated. You must therefore provide a value for the "parserOptions.project" property for @typescript-eslint/parser.
  >   Occurred while linting E:\AdminCode\business_alliances\demo01-eslint-vue-ts\src\main.ts
  >   ```
  >
  > - 根据提示在.eslintrc.cjs配置文件中添加parserOptions.project
  >
  >   ```js
  >   parserOptions: {
  >       ...
  >       project: ['./tsconfig.json']
  >   },
  >   ```

- 启动检查pnpm lint

  > - pnpm add -D @typescript-eslint/parser
