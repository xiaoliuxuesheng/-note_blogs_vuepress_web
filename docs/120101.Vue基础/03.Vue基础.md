---
title: 第三章 Vue基础
date: 2022-01-01 00:01:03
permalink: /pages/a44bd6/
categories:
  - Vue基础
tags:
  - 
author: 
  name: xiaoliuxuesheng
  link: https://gitee.com/xiaoliuxuesheng
---

## 3.1 Vue构造函数

> 只做了解，在Vue3中使用setup语法糖，不涉及直接使用Vue实例属性；

1. el：作用关联html标签作为Vue实例的容器，关联方式有两种：①通过Vue的el实例属性指定、②通过Vue原型属性$mount指定

   ```js
   // 通过Vue的实例属性el指定,内部也是执行$mount函数进行Vue实例挂载
   new Vue({el: '#app'})
   
   //通过Vue原型属性$mount指定
   new Vue({}).$mount("#app")
   ```

2. data：在Vue2中，data属性用于保存Vue实例中的变量，要求data是一个普通函数（不可以是箭头函数，否则this指向window），

   ```js
   // data必须是一个普通函数
   new Vue({
       data: function () {
           return {
               msg: "Hello Vue"
           }
       }
   }).$mount("#app");
   
   // 普通函数的简写
   new Vue({
       data() {
           return {
               msg: "Hello Vue"
           }
       }
   }).$mount("#app");
   // setup函数中的data
   setup(){
       const {ref,reactive} = Vue
       const msg = ref<string>('定义基本类型')
       const obj = reactive<>({
           key: 'value'
       })
       return {msg, obj}
   }
   
   // setup语法糖中的data:<script setup>...</script> 
   const {ref,reactive} = Vue
   const msg = ref<string>('定义基本类型')
   const obj = reactive<>({
       key: 'value'
   }) 
   ```

3. method：被vue管理的函数，不可以使用箭头函数

   ```js
   
   ```

4. computed：也是属于Vue实例的一个属性，区别与data，计算属性的数据来源是data，并且可以缓存

   ```js
   // 完整格式
   // 简写格式
   // Vue3中的计算属性格式
   // setup函数中的计算属性
   // setup语法糖中中的计算属性:<script setup>...</script> 
   ```

5. watch：

   ```js
   
   ```

6. emits

   ```js
   
   ```

## 3.2 Vue语法

> 1. 只有在Vue容器中才可以使用Vue语法
> 2. Vue容器本质就是各种html标签，所以Vue语法的本质作用就是给HTML标签上添加各种数据
>    - 添加数据方式一：在标签体中添加数据使用模版语法（插值表达式）；
>    - 添加数据方式二：在标题属性中使用指令语法（v-开头的vue指令），并且指令语法可以绑定标签属性、标签内容、标签事件等；

### 3.2.1 Vue模版语法

1. 插值表达式语法格式：`{{差值表达式}}`

2. 差值表达式的特点

   - 差值表达式加载过程：浏览器加载模型对象中数据的过程中，首先是会加载HTML页面的DOM元素，所以首先会在页面显示`{{差值表达式}}`字符串，其次会加载外部的Vue的脚本文件，最后会new Vue对象，并且将对象中模型中的值赋值给产值表达式，最终完成数据展示，如果加载Vue延迟会在浏览器中显示出差值表达式。
   - 差值表达式会将data对象中的值以纯文本的方式加载到页面中；
   - 可以在差值表达式的前后任意添加字符串

3. 插值表达式的使用

   ```vue
   1. 读取Vue实例中的变量
   {{变量名称}}
   {{对象.属性名}}
   
   2. 使用数学运算
   {{1+2}}
   
   3. 使用变量值对应的内置函数
   {{name.toUpperCase()}}
   
   4. 使用内置对象
   {{new Date()}}
   
   5. 三元表达式（三元运算符）
   {{ 10>20?'10大于20':'10不大于20' }}
   ```

4. 指令 v-cloak：解决差值表达式闪烁的问题：定义v-cloak样式中隐藏元素的显示，在内存中替换数据后完成数据展示；在差值表达式的DOM元素上定义v-cloak属性，并设置该属性的显示样式为none，当Vue初始化并加载完成后，Vue对象会将改区域中具有改属性的显示样式删除，从而解决差值表达式的闪烁问题；在标签内部使用差值表达式获取到model对象中的指定属性名称的数据，可以在数据前后添加其他字符；

   ```css
   <style>
       [v-cloak]{
           display: none;
       }
   </style>
   ```

   ```html
   <div v-cloak>{{msg}}</div>
   ```

### 3.2.2 Vue指令语法

1. v-bind（简写格式`:`）：数据绑定，引入Vue实例中的变量
   - class样式绑定
   - style样式绑定

2. v-text：纯文本填充，相比差值表达式更简洁， **指定标签中的文本会被属性值替换**

   ```html
   <div v-text='vue实例属性名称'></div>
   ```

3. v-html：内容按普通的HTML插入，不会作为Vue模板进行编译， **建议**：本网站的内部数据是可以使用的，如果是来自第三方数据不建议使用

   ```html
   <div v-html='vue实例属性名称'></div>
   ```

4. v-pre：填充绑定的DOM中的原始信息，跳过编译过程（也不会编译差值表达式）

   ```html
   <div v-pre>{{不会解析vue实例属性名称}}</div>
   ```

5. v-once：表示只会绑定一次数据，不会有数据响应式功能，**优点**：有助于提高性能

   ```html
   <div v-once>{{vue实例属性名称}}</div>
   <div v-once v-text='vue实例属性名称'></div>
   ```

6. v-model：双向数据绑定：主要是针对输入框， 用户输入的数据可以修改模型数据值，模型数据库值的改变页面相应到页面、

   ```html
   <input type="text" v-model='vue实例属性名称'>
   ```

### 3.2.3 Vue事件

#### 1. 事件绑定

- 格式一：**v-on:事件名称**：事件绑定的标准格式

  ```html
  <button v-on:click='JavaScript代码'>按钮</button>
  ```

- 格式二：**@:事件名称**：事件绑定的简写格式

  ```html
  <button @click='JavaScript代码'>按钮</button>
  ```

#### 2. 事件函数的调用方式

> 事件回调函数需要配置在Vue的methods对象中，并且最终页面添加的Vue实例对象上
>
> methods中配置的函数，不建议使用箭头函数，否则this不是Vue实例对象
>
> methods中配置的函数，都是被Vue管理的函数，this的指向是vm或者组件实例对象

- **直接绑定函数名称**：函数默认只有一个参数就是事件对象；

  ```html
  <button v-on:click='函数名称'>按钮</button>
  ```

- **采用函数调用的格式**：可以在函数调用中传递Vue模型中的属性；传递事件需要显示声明，固定参数名称：**$event**；

  ```html
  <button @click='函数名称()'>按钮</button>
  // 等价于下面的：无参数事件函数默认参数是事件对象
  <button @click='函数名称($event)'>按钮</button>
  ```

- **传递普通参数**：如果传递多个参数，事件参数必须放在最后

  ```html
  <button @click='函数名称("普通参数")'>按钮</button>
  <button @click='函数名称("普通参数",$event)'>按钮</button>
  ```

#### 3. 事件修饰符

- 常用事件修饰符：绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略；用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件;

  | 事件修饰符             | 作用                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | **.stop**              | 调用 `event.stopPropagation()`，阻止冒泡事件                 |
  | **.prevent**           | 调用 `event.preventDefault()`，阻止默认事件                  |
  | .once                  | 只触发一次回调                                               |
  | .self                  | 只当事件是从侦听器绑定的元素本身触发时才触发回调。           |
  | .capture               | 使用事件的捕获模式：事件是分捕获阶段和冒泡阶段，默认处理事件的是冒泡阶段 |
  | .passive               | (2.3.0) 以 `{ passive: true }` 模式添加侦听器,事件将会立即触发 |
  | .left                  | (2.2.0) 只当点击鼠标左键时触发                               |
  | .right                 | (2.2.0) 只当点击鼠标右键时触发                               |
  | .middle                | (2.2.0) 只当点击鼠标中键时触发                               |
  | .{keyCode 或 keyAlias} | 只当事件是从特定键触发时才触发回调                           |
  | .native                | 监听组件根元素的原生事件                                     |

- 事件修饰使用实例

  ```html
  案例一：方法处理器
  <button v-on:click="doThis"></button>
  <button @click="doThis"></button>
  
  案例二：动态事件，事件名称是通过获取变量名称获取
  <button v-on:[event]="doThis"></button>
  <button @[event]="doThis"></button>
  
  案例三：方法参数
  <button v-on:click="doThat('hello')"></button>
  <button v-on:click="doThat('hello', $event)"></button>
  
  案例四：停止冒泡
  <button @click.stop="doThis"></button>
  
  案例五：阻止默认行为
  <button @click.prevent="doThis"></button>
  
  案例六：仅阻止默认行为，没有表达式
  <form @submit.prevent></form>
  
  案例七：点击回调只会触发一次
  <button @click.once="doThis"></button>
  
  案例八：修饰符串联
  <button @click.stop.prevent="doThis"></button>
  ```

#### 4. 按键修饰符

- 常用的按键码的别名

  | 建码别名       | 按键                                                         |
  | -------------- | ------------------------------------------------------------ |
  | .enter         | 回车                                                         |
  | .tab           | 制表符                                                       |
  | .delete        | 捕获“删除”和“退格”键                                         |
  | .esc           | ESC退出                                                      |
  | .space         | 空格                                                         |
  | .up            | 上方向键                                                     |
  | .down          | 下方向键                                                     |
  | .left          | 左方向键                                                     |
  | .right         | 右方向键                                                     |
  | **系统修饰键** | 在和 `keyup` 事件一起用时，事件触发时修饰键必须处于按下状态<br />配合keydown使用：正常触发事件 |
  | .ctrl          | Ctrl                                                         |
  | .alt           | Alt                                                          |
  | .shift         | Shift                                                        |
  | .meta          | 在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)<br />Mac 系统键盘上，meta 对应 command 键 (⌘)<br />在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)<br />在 Symbolics 键盘上为“META”或者“Meta” |
  | .exact         | 允许你控制由精确的系统修饰符组合触发的事件                   |

- 事件修饰使用示例

  ```html
  案例一：键别名-回车键
  <input @keyup.enter="onEnter">
  
  案列二：键别名-键码
  <input @keyup.13="onEnter">
  
  案例三：对象语法 (2.4.0+)
  <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
  
  案例四：Alt + C
  <input v-on:keyup.alt.67="clear">
  
  案例五：Ctrl + 单击
  <div v-on:click.ctrl="doSomething">Do something</div>
  
  案例六：有且只有 Ctrl 被按下的时候才触发
  <button v-on:click.ctrl.exact="onCtrlClick">A</button>
  
  案例七：没有任何系统修饰符被按下的时候才触发
  <button v-on:click.exact="onClick">A</button>
  ```

#### 5. 自定义按键修饰符

- 方式一：直接使用建码作为事件修饰符，缺点是使用建码不直观

  ```html
  <input v-on:keyup.67="clear">
  ```

- 方式二：自定义建码：①使用Vue对象定义全局建码配置②使用自定义建码

  ```html
  Vue.conig.keyCode.建码名称=建码值;
  <input v-on:keyup.建码名称="clear">
  ```

## 3.3 组件注册

1. 全局组件
2. 局部组件
3. 异步组件

## 3.4 组件传值

### 1. 父传子

- **props数组**：Prop 是可以在组件上注册的一些自定义 attribute。当一个值传递给一个 prop attribute 的时候，它就变成了那个组件实例的一个 property。可以用一个 `props` 选项将其包含在该组件可接受的 prop 列表中：列表中可以拥有任意数量的 prop，任何值都可以传递给任何 prop。子组件实例中访问这个值，就像访问 `data` 中的值一样。

  ```html
  <blog-post title="My journey with Vue"></blog-post>
  <blog-post title="Blogging with Vue"></blog-post>
  <blog-post title="Why Vue is so fun"></blog-post>
  
  <script>
      Vue.component('blog-post', {
        props: ['title'],
        template: '<h3>{{ title }}</h3>'
      })
  </script>
  ```

- **props对象**：props中的参数可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型；并且可以为 `props` 中的值提供一个带有验证需求的对象，

  ```js
  Vue.component('my-component', {
    props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
        type: String,
        required: true
      },
      // 带有默认值的数字
      propD: {
        type: Number,
        default: 100
      },
      // 带有默认值的对象
      propE: {
        type: Object,
        // 对象或数组默认值必须从一个工厂函数获取
        default: function () {
          return { message: 'hello' }
        }
      },
      // 自定义验证函数
      propF: {
        validator: function (value) {
          // 这个值必须匹配下列字符串中的一个
          return ['success', 'warning', 'danger'].indexOf(value) !== -1
        }
      }
    }
  })
  ```

### 2. 子传父

- **自定义事件注意点**：不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或 property 名，所以不建议使用驼峰命名；由于html大小写不敏感，事件名称会转为全小写，在事件命名推荐使用中横线连接符；

- 数据传输原理是通过子组件的自定义事件将数据以参数的方式传递出去，在使用组件的地方绑定事件并接收参数完成数据传递

  ```html
  1. 子组件中定义事件并绑定参数
  <template id="cpn" >
      <div>
          子组件输入框: <input type="text" @input="inputChange">
      </div>
  </template>
  <script>
      const cpn = Vue.extend({
          template: `#cpn`,
          methods: {
              inputChange (event){
                  this.$emit('sub-change',event.data)
              }
          }
      })
  </script>
  
  2. 在使用组件的部分绑定事件并接收参数
  <div id="app">
      子组件-- <cpn @sub-change="subChange"></cpn>
  </div>
  <script>
      const vm = new Vue({
          el: '#app',
          components: {
              cpn: cpn
          },
          methods: {
              subChange (data) {
                 console.log(data)
              }
          }
      })
  </script>
  ```

- **.sync 修饰符**：

- **.native 修饰符**：

### 3. 同级传值

- **一般大型的项目，推荐使用Vuex来管理组件之间的通信**

- 同级组件不能直接传值，需要一个中间桥梁，可以先将数据传递给公共的父组件，然后父组件再将数据传递给需要的子组件。

  ```html
  <script>
      // 1. 创建一个公共桥梁作为
      const bus = new Vue()
      // 2. 在数据发送方自定义事件将数据发送桥梁
      methods: {
          cpn1Change(event){
              bus.$emit('cnp-one-change',event.data)
          }
      }
      // 3. 在数据接收方的mounted时间钩子函数中始化完成，就开始执行定义的方法
      mounted () {
          bus.$on('cnp-one-change',(val) => {
          })
      }
  </script>
  ```

### 4. $refs

- ref：被用来给元素或子组件注册引用信息，如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：

  ```html
  <!-- `vm.$refs.p` DOM 元素 -->
  <p ref="p">hello</p>
  
  <!-- `vm.$refs.child` 组件实例 -->
  <child-component ref="child"></child-component>
  ```

- $refs：ref引用信息将会注册在父组件的 `$refs` 对象上

  - 当 `v-for` 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。
  - 当引入DOM元素时候：ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们
  - 当引入组件实例时候：`$refs` 也不是响应式的，不应该在模板中做数据绑定。

### 5. $root

- 当前组件树的根 Vue 实例。

### 6. $parent

- 父实例，如果当前实例有的话。

### 7. $children 

- 当前实例的直接子组件。**需要注意 `$children` 并不保证顺序，也不是响应式的。**如果你发现自己正在尝试使用 `$children` 来进行数据绑定，考虑使用一个数组配合 `v-for` 来生成子组件，并且使用 Array 作为真正的来源。

## 3.5 组件插槽

### 1. 插槽概述



### 2. 插槽入门

### 3. 插槽：name

### 4. 插槽：slot-scope

## 3.6 内置组件

