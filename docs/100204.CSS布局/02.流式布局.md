---
title: 第二章 流式布局
date: 2020-01-02 00:04:02
permalink: /pages/30a159/
categories:
  - CSS布局
tags:
  - 
author: 
  name: xiaoliuxuesheng
  link: https://gitee.com/xiaoliuxuesheng
---

## 2.1 浮动流概述

<span style="margin-left: 33px;">&nbsp;</span>在标准流中如果要元素水平排列，虽然可以将元素转换为行内块元素，但是无法控制行内块元素之间的距离，并且水平布局的功能不足以满足网页水平布局的要求；

<span style="margin-left: 33px;">&nbsp;</span>浮动流：浮动是给盒子添加float属性，给盒子创建了一个浮动框，具有浮动框的元素会从原标准流的位置脱离出来，浮动框根据浮动属性的值，浮动框的左边缘或右边缘会贴靠到所包含的块边缘或另一个浮动框的左右边缘；

| float值 | 描述                                                 |
| :------ | :--------------------------------------------------- |
| left    | 元素向左浮动。                                       |
| right   | 元素向右浮动。                                       |
| none    | 默认值。元素不浮动，并会显示在其在文本中出现的位置。 |
| inherit | 规定应该从父元素继承 float 属性的值。                |

<span style="margin-left: 33px;">&nbsp;</span>浮动的注意点：①浮动和标准流的父元素搭配使用（先用标准流排列水平结构，再在水平布局的父元素中定义元素设置浮动属性）②一个元素浮动了理论上该元素的兄弟元素都需要浮动，因为浮动元素会影响后面的标准流；

## 2.2  浮动特性

1. **浮动元素会脱离标准流**
   - 元素浮动后会基于父元素的位置进行左右排版：父级的盒子如果装不下浮动的元素，后面浮动的元素会另起一行；
   - 浮动流是一种“半脱离标准流”的排版方式，浮动后会移动到父元素中指定的位置；
   - 元素浮动后，原来的位置会被释，浮动区域会覆盖掉标准元素，但是浮动的区域不会覆盖对应位置标准流元素中的文本内容
   - 元素浮动不会超越父元素的padding区域和margin区域；
2. **浮动元素会在一行内显示并且元素顶部对齐**
   - 相同方向的浮动元素：先浮动的元素会显示在前面，后浮动的元素会显示在后面；
   - 不同方向的浮动元素：左浮动会找左浮动，右浮动会找右浮动；
   - 浮动元素浮动后的位置：右浮动元素在浮动之前在标准流中的位置确定，只在原来所在行浮动；
3. **浮动元素具有行内块的特性**
   - 浮动流是不区分行内元素、块级元素或行内块元素：浮动所有元素都可以设置宽和高；
   - 浮动元素是不能撑起父元素的高度；
   - 浮动元素是不可以设置`margin 0 auto`的；
4. **浮动元素贴靠现象**
   - 当父元素的宽度足够放置浮动元素时，浮动元素会按顺序贴靠；
   - 当父元素宽度不够时，浮动元素会找现在贴靠元素的上一个浮动元素，直到贴靠在父元素；

## 2.3 消除浮动概述

<span style="margin-left: 33px;">&nbsp;</span>在实际开发中，浮动元素的标准流的父盒子是不会设置高度的，父盒子的高度应该是被子盒子的内容撑开的，但是父盒子中的所有元素浮动后，浮动元素是撑不开父盒子的高度的，所以会导致父盒子的高度为0，下一个标准流元素会被浮动造的影响：浮动不占有原文档流中的位置，所以会对后面的元素排版产生影响，为了解决这些问题，所以要为该元素清除浮动后造成的影响：元素浮动后不会撑开父元素的高度，父元素的高度为0的问题；清除浮动后父盒子会根据子盒子自动检测高度，就不会影响下面的标准流了；清除浮动属性：clear=both，清除浮动的策略是闭合浮动

1. 额外标签法：也称隔墙法，是w3c推荐；在最后浮动元素的元素后新增一个空盒子（**必须是块级元素，不能是行内元素**），并且给盒子设置clear属性，缺点是添加无语义的标签，不优雅；
2. 给父元素添加overflow属性：给父元素添加overflow属性，本义是处理溢出样式的；缺点是无法显示溢出的部分，
3. 给父元素添加after伪元素：本质是也是隔墙法，只是墙是通过样式添加的；原理是after伪元素必须要用content属性，需要将content转为块级元素（display=block），转为块级元素后可以为元素设置clear属性，并且这个内容不再浏览器显示（visibility=hidden），缺点是IE不兼容，需要给添加额外样式（*zoom=1）
4. 给父元素添加双伪元素：after是给父盒子后面添加一个虚拟的墙，再加个before属性给父盒子前面添加一个墙，表示浮动元素完全在父盒子中浮动了

## 2.4 清除浮动

1. **<del>清除浮动方式一</del>**：给父元素设置高度：企业开发中一般盒子的高度是由内容决定，所以不推荐使用盒子高度；

2. **清除浮动方式二**：为浮动元素添加clear属性：添加了clear属性的元素margin属性会失效；解决浮动的本质是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素；

3. **清除浮动方式三**：隔墙法清除浮动

   - 外墙法：在浮动的元素之间添加一个块级元素，并且为该元素设置属性`clear: both`属性，外墙法的第一个浮动元素不要使用`margin-buttom`属性，外墙法的第二个浮动元素不要使用`margin-top`属性，直接为外墙设置高度属性即可；

   - 内墙法：在第一个浮动元素的所有子元素之后添加一个块级元素，并且为该元素设置属性`clear: both`属性，内墙法可以让浮动元素使用margin属性；

   - 使用伪元素选择器为元素前后添加块级元素：`::before` 或`::after`伪元素的content属性，并且设置`height`属性设置为0，`visibility`属性设置为hidden，`clear`属性设置为both；

     ```css
     .clear-fix:after{
         content:"不建议填空";
         height:0px;
         visibality:hidden;
         display:block;
         clear:both;
     }
     
     /** 伪元素有兼容问题:添加兼容处理方式 */
     .clear-fix{
         *zoom:1;
     }
     ```

   - 双伪元素清除浮动：触发bfc，防止外边距合并

     ``` css
     .clear-fix:after,.clear-fix:before{
         content:"";
         display:block;
     }
     .clear-fix{
         clear:both;
     }
     /** 伪元素有兼容问题:添加兼容处理方式 */
     .clear-fix{
         *zoom:1;
     }
     ```

4. **清除浮动方式四**：使用`overflow: hidden`属性：在IE6中无效，需要添加兼容属性`*zoom:1`值；缺点子元素中过多的内容被隐藏；

